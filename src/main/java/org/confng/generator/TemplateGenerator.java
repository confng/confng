package org.confng.generator;

import lombok.extern.slf4j.Slf4j;
import org.confng.api.ConfNGKey;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

/**
 * Generates environment-specific configuration templates from ConfNGKey enums.
 *
 * <p>This tool creates configuration file templates for different environments
 * (dev, staging, production) based on your ConfNGKey enum definitions.</p>
 *
 * <h3>Example Usage:</h3>
 * <pre>{@code
 * TemplateGenerator generator = new TemplateGenerator();
 * 
 * // Generate templates for all environments
 * generator.generateTemplates(MyConfig.class, "config/templates");
 * 
 * // Generate for specific environment
 * generator.generateTemplate(MyConfig.class, "production", "config/application-prod.properties");
 * }</pre>
 *
 * @author Bharat Kumar Malviya
 * @author GitHub: github.com/imBharatMalviya
 * @since 1.1.0
 */
@Slf4j
public class TemplateGenerator {
    
    private static final List<String> DEFAULT_ENVIRONMENTS = Arrays.asList("dev", "staging", "production");
    
    private List<String> environments = new ArrayList<>(DEFAULT_ENVIRONMENTS);
    private boolean includeComments = true;
    private boolean includeDefaults = true;
    private boolean maskSensitiveDefaults = true;
    private String format = "properties"; // properties, yaml, json
    
    public void setEnvironments(List<String> environments) {
        this.environments = new ArrayList<>(environments);
    }
    
    public void setIncludeComments(boolean includeComments) {
        this.includeComments = includeComments;
    }
    
    public void setIncludeDefaults(boolean includeDefaults) {
        this.includeDefaults = includeDefaults;
    }
    
    public void setMaskSensitiveDefaults(boolean maskSensitiveDefaults) {
        this.maskSensitiveDefaults = maskSensitiveDefaults;
    }
    
    public void setFormat(String format) {
        this.format = format;
    }
    
    /**
     * Generates configuration templates for all configured environments.
     */
    public <E extends Enum<E> & ConfNGKey> void generateTemplates(Class<E> keyClass, String outputDir) throws IOException {
        for (String env : environments) {
            String filename = "application-" + env + "." + getExtension();
            Path outputPath = Path.of(outputDir, filename);
            generateTemplate(keyClass, env, outputPath.toString());
        }
    }
    
    /**
     * Generates a configuration template for a specific environment.
     */
    public <E extends Enum<E> & ConfNGKey> void generateTemplate(Class<E> keyClass, String environment, String outputPath) throws IOException {
        E[] keys = keyClass.getEnumConstants();
        Path path = Path.of(outputPath);
        Files.createDirectories(path.getParent());
        
        switch (format.toLowerCase()) {
            case "yaml":
            case "yml":
                generateYamlTemplate(keys, environment, path);
                break;
            case "json":
                generateJsonTemplate(keys, environment, path);
                break;
            default:
                generatePropertiesTemplate(keys, environment, path);
        }
        
        log.info("Generated {} template at {}", environment, outputPath);
    }
    
    private <E extends Enum<E> & ConfNGKey> void generatePropertiesTemplate(E[] keys, String env, Path path) throws IOException {
        try (PrintWriter writer = new PrintWriter(new FileWriter(path.toFile()))) {
            writer.println("# Configuration template for " + env + " environment");
            writer.println("# Generated by ConfNG TemplateGenerator");
            writer.println();
            
            String currentSection = "";
            for (E key : keys) {
                String keyName = key.getKey();
                String section = keyName.contains(".") ? keyName.substring(0, keyName.indexOf('.')) : "";
                
                if (!section.equals(currentSection)) {
                    if (!currentSection.isEmpty()) {
                        writer.println();
                    }
                    if (includeComments && !section.isEmpty()) {
                        writer.println("# " + section.toUpperCase() + " Configuration");
                    }
                    currentSection = section;
                }
                
                // Mark keys without defaults as potentially required
                if (includeComments && key.getDefaultValue() == null) {
                    writer.println("# NO DEFAULT - likely required");
                }
                
                String value = getTemplateValue(key, env);
                writer.println(keyName + "=" + value);
            }
        }
    }
    
    private <E extends Enum<E> & ConfNGKey> void generateYamlTemplate(E[] keys, String env, Path path) throws IOException {
        try (PrintWriter writer = new PrintWriter(new FileWriter(path.toFile()))) {
            writer.println("# Configuration template for " + env + " environment");
            writer.println("# Generated by ConfNG TemplateGenerator");
            writer.println();
            
            Map<String, Object> yamlStructure = new LinkedHashMap<>();
            
            for (E key : keys) {
                String[] parts = key.getKey().split("\\.");
                Map<String, Object> current = yamlStructure;
                
                for (int i = 0; i < parts.length - 1; i++) {
                    @SuppressWarnings("unchecked")
                    Map<String, Object> next = (Map<String, Object>) current.computeIfAbsent(parts[i], k -> new LinkedHashMap<>());
                    current = next;
                }
                
                current.put(parts[parts.length - 1], getTemplateValue(key, env));
            }
            
            writeYaml(writer, yamlStructure, 0);
        }
    }
    
    private void writeYaml(PrintWriter writer, Map<String, Object> map, int indent) {
        String prefix = "  ".repeat(indent);
        for (Map.Entry<String, Object> entry : map.entrySet()) {
            if (entry.getValue() instanceof Map) {
                writer.println(prefix + entry.getKey() + ":");
                @SuppressWarnings("unchecked")
                Map<String, Object> nested = (Map<String, Object>) entry.getValue();
                writeYaml(writer, nested, indent + 1);
            } else {
                writer.println(prefix + entry.getKey() + ": " + entry.getValue());
            }
        }
    }

    private <E extends Enum<E> & ConfNGKey> void generateJsonTemplate(E[] keys, String env, Path path) throws IOException {
        try (PrintWriter writer = new PrintWriter(new FileWriter(path.toFile()))) {
            writer.println("{");

            for (int i = 0; i < keys.length; i++) {
                E key = keys[i];
                String value = getTemplateValue(key, env);
                String comma = (i < keys.length - 1) ? "," : "";
                writer.println("  \"" + key.getKey() + "\": \"" + escapeJson(value) + "\"" + comma);
            }

            writer.println("}");
        }
    }

    private <E extends Enum<E> & ConfNGKey> String getTemplateValue(E key, String env) {
        String keyName = key.getKey().toLowerCase();

        // Check if sensitive - use ConfNGKey.isSensitive() first, then fall back to pattern matching
        boolean isSensitiveValue = key.isSensitive() || isSensitiveByPattern(keyName);
        if (isSensitiveValue && maskSensitiveDefaults) {
            return "${" + key.getKey().toUpperCase().replace('.', '_') + "}";
        }

        // Use default value if available
        if (includeDefaults && key.getDefaultValue() != null) {
            return key.getDefaultValue();
        }

        // Generate placeholder
        return "${" + key.getKey().toUpperCase().replace('.', '_') + "}";
    }

    private boolean isSensitiveByPattern(String key) {
        return key.contains("password") || key.contains("secret") ||
               key.contains("token") || key.contains("key") ||
               key.contains("credential") || key.contains("auth") ||
               key.contains("private");
    }

    private String getExtension() {
        switch (format.toLowerCase()) {
            case "yaml":
            case "yml":
                return "yaml";
            case "json":
                return "json";
            default:
                return "properties";
        }
    }

    private String escapeJson(String s) {
        return s.replace("\\", "\\\\").replace("\"", "\\\"");
    }
}
